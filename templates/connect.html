<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è®¾å¤‡è¿æ¥ä¸é¢„è§ˆï¼ˆåç«¯é©±åŠ¨ï¼‰</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; padding: 16px; }
        .row { display: flex; gap: 16px; align-items: flex-start; }
        .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
        .btn { padding: 8px 12px; border: 1px solid #666; border-radius: 6px; cursor: pointer; background: #f7f7f7; }
        .btn.primary { background: #2b7cff; color: #fff; border-color: #2b7cff; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
        .icon-container { display: flex; gap: 10px; width: 100%; margin-top: 8px; }
        .icon { padding: 6px; font-size: 18px; cursor: pointer; color: #333; transition: color 0.3s ease; }
        .icon:hover { color: #2b7cff; }
        .icon-container i:nth-child(4) { margin-left: auto; }
        .video-wrapper { position: relative; width: 100%; max-width: 720px; height: 420px; background: #000; border-radius: 8px; overflow: hidden; margin-top: 8px; }
        video, img.preview { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 100%; max-height: 100%; width: auto; height: auto; background: black; }
        #status { font-family: Arial, sans-serif; color: #333; }
        #canvas, #screen { display: none; }
        .input-inline { display: inline-flex; align-items: center; gap: 8px; }
        .input-inline input { width: 280px; padding: 6px 8px; border: 1px solid #ccc; border-radius: 6px; }
    </style>
    <!-- ä½¿ç”¨æœ¬åœ° socket.io ä¸ JMuxer èµ„æº -->
    <script src="/ws-assets/js/socket.io.js"></script>
    <script src="/ws-assets/js/input.js"></script>
    <script src="/ws-assets/js/exp-golomb.js"></script>
    <script src="/ws-assets/js/h264-sps-parser.js"></script>
    <script src="/ws-assets/js/video_parser.js"></script>
    <script src="/ws-assets/js/jmuxer.min.js"></script>
</head>
<body>
    <h1>è¿æ¥è®¾å¤‡ï¼ˆåç«¯ Scrcpyï¼‰</h1>

    <div class="card">
        <div style="display:flex; gap:8px; align-items:center; flex-wrap: wrap;">
            <button id="startBackendPreview" class="btn primary">è¿æ¥å¹¶é¢„è§ˆ</button>
            <span id="status">æœªè¿æ¥</span>
        </div>
        <div class="mono" id="log" style="margin-top:8px; white-space:pre-wrap;"></div>
        <div class="icon-container">
            <i id="power-icon" class="icon" title="ç”µæº">â»</i>
            <i id="volume-down-icon" class="icon" title="éŸ³é‡-">ğŸ”‰-</i>
            <i id="volume-up-icon" class="icon" title="éŸ³é‡+">ğŸ”Š+</i>
            <i id="back-icon" class="icon" title="è¿”å›">â†</i>
            <i id="home-icon" class="icon" title="ä¸»é¡µ">âŒ‚</i>
            <i id="menu-icon" class="icon" title="èœå•">â‰¡</i>
        </div>
        <div class="video-wrapper">
            <video id="player" autoplay muted webkit-playsinline playsinline x5-playsinline></video>
            <img id="mjpeg" class="preview" alt="MJPEG é¢„è§ˆ" style="display:none;" />
        </div>
    </div>

    <div class="row" style="margin-top:16px;">
        <div class="card" style="flex:1;">
            <h3>è®¾å¤‡ä¿¡æ¯</h3>
            <div>å‹å·ï¼š<span id="model">-</span></div>
            <div>åˆ†è¾¨ç‡ï¼š<span id="resolution">-</span></div>
            <div style="margin-top:8px; display:flex; gap:8px;">
                <button id="readModel" class="btn">è¯»å–å‹å·</button>
            </div>
        </div>
        <div class="card" style="flex:1;">
            <h3>ADB Shell</h3>
            <textarea id="shellInput" rows="4" style="width:100%;" placeholder="è¾“å…¥ ADB shell æŒ‡ä»¤ï¼Œä¾‹å¦‚ï¼šgetprop ro.product.model"></textarea>
            <div style="margin-top:8px; display:flex; gap:8px;">
                <button id="runShell" class="btn">æ‰§è¡Œ</button>
            </div>
            <pre id="shellOutput" class="mono" style="margin-top:8px; min-height:80px;"></pre>
        </div>
    </div>

    <script>
        // åç«¯ ADBï¼šé€šè¿‡ HTTP è°ƒç”¨åç«¯æ‰§è¡Œ shell
        function backendAdb() {
            return {
                shell: async (cmd) => {
                    const res = await fetch('/api/shell', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ cmd })
                    });
                    const data = await res.json();
                    if (!data.ok) throw new Error('åç«¯ shell æ‰§è¡Œå¤±è´¥');
                    return data.output || '';
                },
            };
        }

        const logEl = document.getElementById('log');
        const statusEl = document.getElementById('status');
        const modelEl = document.getElementById('model');
        const resolutionEl = document.getElementById('resolution');
        const connectBtn = document.getElementById('startBackendPreview');
        const readModelBtn = document.getElementById('readModel');
        const runShellBtn = document.getElementById('runShell');
        const shellInput = document.getElementById('shellInput');
        const shellOutput = document.getElementById('shellOutput');
        const videoElement = document.getElementById('player');
        const mjpegEl = document.getElementById('mjpeg');

        function appendLog(msg) {
            logEl.textContent += `\n${msg}`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        async function readModel() {
            try {
                const out = await backendAdb().shell('getprop ro.product.model');
                modelEl.textContent = (out || '').trim() || '-';
            } catch (e) {
                console.error(e);
                appendLog('è¯»å–å‹å·å¤±è´¥ï¼š' + (e?.message || e));
            }
        }

        async function runShell() {
            const cmd = shellInput.value.trim();
            if (!cmd) return;
            try {
                const text = await backendAdb().shell(cmd);
                shellOutput.textContent = text;
            } catch (e) {
                console.error(e);
                shellOutput.textContent = 'æ‰§è¡Œå¤±è´¥ï¼š' + (e?.message || e);
            }
        }

        // è§£æä¸è¾“å…¥åˆå§‹åŒ–
        let input = null;
        let socket = null;
        let jmuxer = null;
        let fallbackTimer = null;

        function initInput(width, height) {
            function input_data_cb(data) {
                socket.emit('control_data', data);
            }
            if (typeof ScrcpyInput !== 'undefined') {
                input = new ScrcpyInput(input_data_cb, videoElement, width, height, false);

                const powerIcon = document.getElementById('power-icon');
                const volumeDownIcon = document.getElementById('volume-down-icon');
                const volumeUpIcon = document.getElementById('volume-up-icon');
                const backUpIcon = document.getElementById('back-icon');
                const homeUpIcon = document.getElementById('home-icon');
                const menuUpIcon = document.getElementById('menu-icon');

                powerIcon.addEventListener('mousedown', function () { input.screen_on_off(0); });
                powerIcon.addEventListener('mouseup', function () { input.screen_on_off(1); });
                volumeDownIcon.addEventListener('mousedown', (event) => { input.snedKeyCode(event, 0, 25); });
                volumeDownIcon.addEventListener('mouseup', (event) => { input.snedKeyCode(event, 1, 25); });
                volumeUpIcon.addEventListener('mousedown', (event) => { input.snedKeyCode(event, 0, 24); });
                volumeUpIcon.addEventListener('mouseup', (event) => { input.snedKeyCode(event, 1, 24); });
                backUpIcon.addEventListener('mousedown', (event) => { input.snedKeyCode(event, 0, 4); });
                backUpIcon.addEventListener('mouseup', (event) => { input.snedKeyCode(event, 1, 4); });
                homeUpIcon.addEventListener('mousedown', (event) => { input.snedKeyCode(event, 0, 3); });
                homeUpIcon.addEventListener('mouseup', (event) => { input.snedKeyCode(event, 1, 3); });
                menuUpIcon.addEventListener('mousedown', (event) => { input.snedKeyCode(event, 0, 187); });
                menuUpIcon.addEventListener('mouseup', (event) => { input.snedKeyCode(event, 1, 187); });
            } else {
                // æ—  ScrcpyInput æ—¶ï¼Œä½¿ç”¨åç«¯ ADB ä½œä¸ºå›é€€
                const powerIcon = document.getElementById('power-icon');
                const volumeDownIcon = document.getElementById('volume-down-icon');
                const volumeUpIcon = document.getElementById('volume-up-icon');
                const backUpIcon = document.getElementById('back-icon');
                const homeUpIcon = document.getElementById('home-icon');
                const menuUpIcon = document.getElementById('menu-icon');

                const sendKeyEvent = async (code) => {
                    try {
                        const res = await fetch('/api/shell', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ cmd: `input keyevent ${code}` })
                        });
                        const data = await res.json();
                        if (!data.ok) throw new Error('åç«¯æ‰§è¡Œå¤±è´¥');
                        appendLog(`å·²å‘é€æŒ‰é”® ${code}`);
                    } catch (e) {
                        appendLog(`æŒ‰é”®å¤±è´¥ ${code}: ${e?.message || e}`);
                    }
                };

                powerIcon?.addEventListener('click', () => sendKeyEvent(26));
                volumeDownIcon?.addEventListener('click', () => sendKeyEvent(25));
                volumeUpIcon?.addEventListener('click', () => sendKeyEvent(24));
                backUpIcon?.addEventListener('click', () => sendKeyEvent(4));
                homeUpIcon?.addEventListener('click', () => sendKeyEvent(3));
                menuUpIcon?.addEventListener('click', () => sendKeyEvent(82));
            }
        }

        let feedCount = 0;
        const parser = new VideoParser(({ type, data }) => {
            if (type === 'nalu') {
                jmuxer && jmuxer.feed({ video: data });
            } else if (type === 'init') {
                jmuxer && jmuxer.feed({ video: data["sps"] });
                jmuxer && jmuxer.feed({ video: data["pps"] });
            } else if (type === 'screen_size') {
                initInput(data["width"], data["height"]);
            } else if (type === 'size_change') {
                if (input) { input.resizeScreen(data["width"], data["height"]); }
            }
        });

        function startMjpegFallback() {
            appendLog('æœªæ”¶åˆ°è§†é¢‘å¸§ï¼Œå¯ç”¨ MJPEG å›é€€æ˜¾ç¤ºâ€¦');
            statusEl.textContent = 'å·²è¿æ¥ï¼ˆMJPEG å›é€€ï¼‰';
            videoElement.style.display = 'none';
            mjpegEl.style.display = 'block';
            mjpegEl.src = '/stream';
        }

        function startPreview() {
            // æ¸…ç†æ—§è¿æ¥
            try { if (socket) socket.disconnect(); } catch(e) {}
            feedCount = 0;
            if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = null; }
            mjpegEl.style.display = 'none';
            if (mjpegEl.src) mjpegEl.src = '';
            videoElement.style.display = 'block';

            jmuxer = new JMuxer({
                node: 'player', mode: 'video', fps: 60, flushingTime: 0, clearBuffer: true,
                onReady: () => {
                    appendLog('MSE å°±ç»ªï¼Œç­‰å¾…è§†é¢‘æ•°æ®â€¦');
                    if (videoElement) {
                        videoElement.controls = false;
                        videoElement.muted = true;
                        videoElement.autoplay = true;
                        videoElement.playsInline = true;
                        try { videoElement.play(); } catch(e) { appendLog('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢: ' + (e?.message||e)); }
                    }
                    // å¯åŠ¨è¶…æ—¶å›é€€ï¼š1.5s æœªæ”¶åˆ°å¸§åˆ™åˆ‡æ¢åˆ° MJPEG
                    fallbackTimer = setTimeout(() => {
                        if (feedCount === 0) startMjpegFallback();
                    }, 1500);
                },
                onError: (err) => { appendLog('MSE é”™è¯¯ï¼š' + err.message); }
            });

            // è¿æ¥åˆ°åŒæºçš„ Socket.IO æœåŠ¡ï¼ŒæŒ‰ web-scrcpy çš„ç¨³å®šé…ç½®
            socket = io({ reconnection: false, autoConnect: true });
            
            socket.on('video_data', async (data) => {
                try {
                    let arrBuf = null;
                    if (data instanceof ArrayBuffer) {
                        arrBuf = data;
                    } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
                        arrBuf = await data.arrayBuffer();
                    } else if (data && data.buffer instanceof ArrayBuffer) {
                        arrBuf = data.buffer;
                    } else if (data && typeof data === 'object' && typeof data.byteLength === 'number') {
                        // Buffer-like
                        arrBuf = data;
                    }
                    if (!arrBuf) {
                        appendLog('æ”¶åˆ°æœªçŸ¥ç±»å‹è§†é¢‘å—ï¼š' + Object.prototype.toString.call(data));
                        return;
                    }
                    const newData = new Uint8Array(arrBuf);
                    feedCount += 1;
                    parser.appendData(newData);
                } catch (e) {
                    appendLog('å¤„ç†è§†é¢‘å—å¤±è´¥ï¼š' + (e?.message || e));
                }
            });
            
            // æ–°å¢ï¼šæ”¶åˆ°æœåŠ¡å™¨ç»Ÿè®¡ï¼ŒååŠ©å®šä½æ˜¯å¦æœ‰è§†é¢‘å¸§å‘é€
            socket.on('video_stats', (s) => {
                appendLog(`æœåŠ¡å™¨å‘é€ç»Ÿè®¡ packets=${s?.packets||0} bytes=${s?.bytes||0}`);
            });

            socket.on('connect', () => {
                statusEl.textContent = 'å·²è¿æ¥';
                appendLog('å·²è¿æ¥ï¼Œæ¥æ”¶è§†é¢‘æ•°æ®ä¸­â€¦');
            });

            socket.on('disconnect', () => {
                statusEl.textContent = 'æœªè¿æ¥';
                appendLog('è¿æ¥å…³é—­ï¼Œè¯·é‡æ–°å¯åŠ¨é¢„è§ˆ');
                if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = null; }
                mjpegEl.style.display = 'none';
                if (mjpegEl.src) mjpegEl.src = '';
            });

            socket.on('error', (error) => {
                appendLog('WebSocket é”™è¯¯ï¼š' + (error?.message || error));
            });

            window.addEventListener('beforeunload', () => { socket && socket.disconnect(); });
        }

        connectBtn.addEventListener('click', startPreview);
        readModelBtn.addEventListener('click', readModel);
        runShellBtn.addEventListener('click', runShell);
    </script>
</body>
</html>